Class {
	#name : 'TetrisDrawableAreaWidget',
	#superclass : 'CwExtendedComposite',
	#instVars : [
		'cellArray',
		'rowCount',
		'gc',
		'gcValues',
		'columnCount',
		'fallingBlock',
		'currentFallingBlock',
		'fullRefreshRequired',
		'shouldShowGrid'
	],
	#pools : [
		'CgConstants'
	],
	#category : 'VATetris'
}

{ #category : 'IS_generated',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget class >> _PRAGMA_IS_ [

	"%%PRAGMA DECLARE
	(name: IS_TetrisDrawableAreaWidget isPool: true isConstant: false)
	(pool: IS_TetrisDrawableAreaWidget declarations: (
		(name: IS_instanceInterfaceSpec isConstant: false)
	))"
]

{ #category : 'IS_generated',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget class >> abtPrimFlushInterfaceSpecCache [

	IS_TetrisDrawableAreaWidget associationsDo: [: poolDictionaryAssoc | poolDictionaryAssoc value: nil].
	super abtPrimFlushInterfaceSpecCache
]

{ #category : 'IS_generated',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget class >> defaultResourceSnapshotInfo [
	"Answer a collection of CwResourceSnapshots specifying which
	 resources to save, and the selectors used to get and set the
	 resource values."

	"Save the width and height of every widget.  When a widget is
	created, the widget choose their preferred size and this affects
	the preferred size of the shell and the size of the widgets inside
	the shell.  For example, a list will attempt to grow wide enough
	to show the widest item.  If the contents of the list is changed
	after the window is realized, the list will request a new size but
	often this request is refused.  When the list is restored from
	saved resources (ie. with the new contents), this request may
	be granted.  This means that the list will have a different size
	in a restored window than when it was saved.  To avoid this
	situation, width and height are saved for every widget."

	^super defaultResourceSnapshotInfo
		add: (CwResourceSnapshot getSelector: #cellArray setSelector: #cellArray:);
		add: (CwResourceSnapshot getSelector: #gcValues setSelector: #gcValues:);
		add: (CwResourceSnapshot getSelector: #fallingBlock setSelector: #fallingBlock:);
		add:
			(CwResourceSnapshot getSelector: #currentFallingBlock setSelector: #currentFallingBlock:);
		add:
			(CwResourceSnapshot getSelector: #fullRefreshRequired setSelector: #fullRefreshRequired:);
		add: (CwResourceSnapshot getSelector: #shouldShowGrid setSelector: #shouldShowGrid:);
		yourself
]

{ #category : 'IS_generated',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget class >> IS_instanceInterfaceSpec [
	"Private - ** Warning ** This method is generated by VisualAge and should not
	be modified or deleted. This method is responsible for returning a featureSpec
	that describes the implementation of a particular feature of the receiver"

	^IS_TetrisDrawableAreaWidget::IS_instanceInterfaceSpec notNil
		ifTrue: [IS_TetrisDrawableAreaWidget::IS_instanceInterfaceSpec]
		ifFalse: [
		IS_TetrisDrawableAreaWidget::IS_instanceInterfaceSpec := AbtInterfaceSpec new]
]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> cellArray [
	"Return the value of cellArray."

	^cellArray
]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> cellArray: anArray [
	"Save the value of cellArray."

	cellArray := anArray.

]

{ #category : 'Internal',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> cellHeight [

	^(self height / self rowCount) rounded
]

{ #category : 'Internal',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> cellRectangleAt: aPoint [

	| cellWidth cellHeight |
	cellWidth := self cellWidth.
	cellHeight := self cellHeight.
	
	^Rectangle origin: (aPoint * (cellWidth @ cellHeight)) extent: (cellWidth @ cellHeight)
]

{ #category : 'Internal',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> cellWidth [

	^(self width / self columnCount) rounded
]

{ #category : 'API' }
TetrisDrawableAreaWidget >> clear [
	"Fill the receiver with its background colour."

	| pixelColourValue |
	pixelColourValue := self pixelValueOfRgbColour: (self backgroundColor).

	^self fillWithPixelValue: pixelColourValue
]

{ #category : 'API' }
TetrisDrawableAreaWidget >> clearFallingBlock [

	| blockLocation cellWidth cellHeight |
	cellWidth := self cellWidth.
	cellHeight := self cellHeight.

	( currentFallingBlock notNil ) ifFalse: [ ^nil ].

	self clearRectangle: ((currentFallingBlock location * (cellWidth @ cellHeight))
		extent: ((currentFallingBlock width @ currentFallingBlock height) * (cellWidth @ cellHeight))).

	^self
]

{ #category : 'Internal - Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> clearRectangle: aRectangle [
	"Fill the specified rectangle with the receiver's background colour."

	| pixelColourValue |
	pixelColourValue := self pixelValueOfRgbColour: self backgroundColor.

	^self fillRectangle: aRectangle pixelValue: pixelColourValue
]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> columnCount [
	"Return the value of columnCount."

	^columnCount
]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> columnCount: anInteger [
	"Save the value of columnCount."

	columnCount := anInteger.

]

{ #category : 'Creation' }
TetrisDrawableAreaWidget >> createPrimaryWidget: theName parent: parent argBlock: argBlock [
	"Create and answer the basic widget that is the root of the widget hierarchy
	 for the receiver's widget system."

	| widget sourceAdapter|
	widget := CwDrawingArea
		createWidget: theName
		parent: parent
		argBlock: argBlock.

	widget
		addCallback: XmNdestroyCallback
			receiver: self
			selector: #destroy:clientData:callData:
			clientData: nil;
		addCallback: XmNresizeCallback
			receiver: self
			selector: #resize:clientData:callData:
			clientData: nil;
		addCallback: XmNexposeCallback
			receiver: self
			selector: #expose:clientData:callData:
			clientData: nil;
		addCallback: XmNfocusCallback
			receiver: self
			selector: #focus:clientData:callData:
			clientData: nil;
		addCallback: XmNlosingFocusCallback
			receiver: self
			selector: #losingFocus:clientData:callData:
			clientData: nil;

		addEventHandler: ButtonPressMask | ButtonReleaseMask | Button1MotionMask | Button3MotionMask | KeyPressMask
			receiver: self
			selector: #input:clientData:event:
			clientData: nil;

		yourself.

	^widget
]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> currentFallingBlock [

	^currentFallingBlock
]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> currentFallingBlock: anObject [

	currentFallingBlock := anObject
]

{ #category : 'Callbacks' }
TetrisDrawableAreaWidget >> destroy: widget clientData: clientData callData: callData [
	"The drawing area has been destroyed."

	"Free the GraphicsContext."
	( gc notNil ) ifTrue: [ self gc freeGC ].

	^self
]

{ #category : 'Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> drawArcOn: aCgDrawable at: origin width: width height: height fromAngle: startAngle toAngle: endAngle lineWidth: anInteger pixelValue: aPixelValue [
	"Draw an arc at the given coordinates between the specified angles.  The angles are specified in degrees."

	| localGC localGCValues |
	localGCValues	:= CgGCValues new.
	localGC := aCgDrawable createGC: None values: localGCValues.

	"Make sure we have the currect colour setting.  If not, change it."
	( localGCValues foreground = aPixelValue ) ifFalse: [
		localGCValues foreground: aPixelValue.
		localGC
			changeGC: GCForeground
			values: localGCValues
	].

	"Make sure we have the currect lineWidth setting.  If not, change it."
	( localGCValues lineWidth = anInteger ) ifFalse:[
		localGCValues lineWidth: anInteger.
		localGC
			changeGC: GCLineWidth
			values: localGCValues
		].

	"Draw the arc."
	^aCgDrawable drawArc: localGC x: origin x y: origin y
		width: width height: height angle1: (startAngle * 64) angle2: (endAngle * 64)
]

{ #category : 'API' }
TetrisDrawableAreaWidget >> drawBlock: aTetrisBlock [

	| blockLocation blockFootprint blockColour |
	blockLocation := aTetrisBlock location.
	blockFootprint := aTetrisBlock footprint.
	blockColour := aTetrisBlock colour.

	"Draw the Block in its current location."
	blockFootprint doWithIndex: [ :row :rowIndex |
		row doWithIndex: [ :occupied :columnIndex |
			( occupied = 1 ) ifTrue: [
				self fillRectangle: (self cellRectangleAt: ((columnIndex @ rowIndex) + (blockLocation - (1 @ 1)))) pixelValue: blockColour
			].
		].
	].

	^aTetrisBlock
]

{ #category : 'API' }
TetrisDrawableAreaWidget >> drawFallingBlock [

	( self fallingBlock notNil ) ifFalse: [ ^nil ].

	"First, we clear the space occupied by the copy we took of the fallingBlock,
	  the last time we drew it."
	self clearFallingBlock.

	self drawBlock: self fallingBlock.

	"Copy the fallingBlock, to keep track of where it is right now, so we know the spot that will need
	  to be cleared when the block moves."
	currentFallingBlock := self fallingBlock copy.

	^self
]

{ #category : 'API' }
TetrisDrawableAreaWidget >> drawGrid [

	| cellWidth cellHeight |
	cellWidth := self cellWidth.
	cellHeight := self cellHeight.

	self drawRectangle: (0 @ 0) width: (self width - 1) height: (self height - 1).

	1 to: self columnCount do: [ :i |
		self drawLineFrom: ((i * cellWidth) @ 0) to: ((i * cellWidth) @ self height) ].

	1 to: self rowCount do: [ :i |
		self drawLineFrom: (0 @ (i * cellHeight)) to: (self width @ (i * cellHeight)) ].

	^self
]

{ #category : 'Internal - Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> drawLineFrom: aStartPoint to: anEndPoint [
	"Draw the given line."

	^self drawLineFrom: aStartPoint to: anEndPoint width: 1 pixelValue: 0
]

{ #category : 'Internal - Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> drawLineFrom: aStartPoint to: anEndPoint width: aWidth on: aCgDrawable pixelValue: aPixelValue [
	"Draw the given line with the given colour."

	| height localGC |
	localGC := self gc.

	"Make sure we have the currect colour setting.  If not, change it."
	( self gcValues foreground = aPixelValue ) ifFalse: [
		self gcValues foreground: aPixelValue.
		localGC
			changeGC: GCForeground
			values: self gcValues
	].

	"Make sure we have the currect lineWidth setting.  If not, change it."
	( self gcValues lineWidth = aWidth ) ifFalse:[
		self gcValues lineWidth: aWidth.
		localGC
			changeGC: GCLineWidth
			values: self gcValues
		].

	"Draw the line."
	^aCgDrawable drawLine: localGC x1: aStartPoint x y1: aStartPoint y x2: anEndPoint x y2: anEndPoint y

]

{ #category : 'Internal - Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> drawLineFrom: aStartPoint to: anEndPoint width: aWidth pixelValue: aPixelValue [
	"Draw the given line with the given colour."

	^self drawLineFrom: aStartPoint to: anEndPoint width: aWidth on: self window pixelValue: aPixelValue
]

{ #category : 'Internal - Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> drawRectangle: origin width: width height: height [

	^self drawRectangle: origin width: width height: height lineWidth: 1 pixelValue: 0
]

{ #category : 'Internal - Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> drawRectangle: origin width: width height: height lineWidth: anInteger pixelValue: aPixelValue [
	"Draw a rectangle at the given coordinates."

	"Make sure we have the currect colour setting.  If not, change it."
	( self gcValues foreground = aPixelValue ) ifFalse: [
		self gcValues foreground: aPixelValue.
		self gc
			changeGC: GCForeground
			values: self gcValues
	].

	"Make sure we have the currect lineWidth setting.  If not, change it."
	( self gcValues lineWidth = anInteger ) ifFalse:[
		self gcValues lineWidth: anInteger.
		self gc
			changeGC: GCLineWidth
			values: self gcValues
		].

	"Draw the rectangle."
	^self window drawRectangle: self gc
		x: origin x
		y: origin y
		width: width
		height: height
]

{ #category : 'Internal - Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> drawRectangle: origin width: width height: height pixelValue: aPixelValue [
	"Draw a rectangle at the given coordinates."

	^self drawRectangle: origin width: width height: height lineWidth: 1 pixelValue: aPixelValue
]

{ #category : 'API' }
TetrisDrawableAreaWidget >> drawStationaryBlocks [

	self cellArray doWithIndex: [ :row :rowIndex |
		row doWithIndex: [ :colour :columnIndex |
			( colour notNil ) ifTrue: [ self fillRectangle: (self cellRectangleAt: ((columnIndex - 1) @ (rowIndex - 1))) pixelValue: colour ]
		].
	].

	^self cellArray
]

{ #category : 'Callbacks' }
TetrisDrawableAreaWidget >> expose: widget clientData: clientData callData: callData [
	"The drawing area has been exposed."

	| rect |
	widget isDestroyed ifTrue: [ ^self ].
	self gc isNil ifTrue: [ ^self ].
	rect := callData event rectangle.
	self window
		clearArea: rect origin x
		y: rect origin y
		width: rect width
		height: rect height
		exposures: false.
	self gc
		setClipRectangles: 0
		clipYOrigin: 0
		rectangles: (Array with: rect)
		ordering: Unsorted.
	self refresh.
	self gc setClipMask: nil
]

{ #category : 'Accessors',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> fallingBlock [

	^fallingBlock
]

{ #category : 'Accessors',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> fallingBlock: aTetrisBlock [

	fallingBlock := aTetrisBlock
]

{ #category : 'Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> fillArcOn: aCgDrawable at: origin width: width height: height fromAngle: startAngle toAngle: endAngle pixelValue: aPixelValue [
	"Fill an arc at the given coordinates between the specified angles.  The angles are specified in degrees."

	| localGC localGCValues |
	localGCValues	:= CgGCValues new.
	localGC := aCgDrawable createGC: None values: localGCValues.

	"Make sure we have the currect colour setting.  If not, change it."
	( localGCValues foreground = aPixelValue ) ifFalse: [
		localGCValues foreground: aPixelValue.
		localGC
			changeGC: GCForeground
			values: localGCValues
	].

	"Fill the arc."
	^aCgDrawable fillArc: localGC
		x: origin x
		y: origin y
		width: width
		height: height
		angle1: (startAngle * 64)
		angle2: (endAngle * 64)
]

{ #category : 'Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> fillRectangle: aRectangle on: aCgDrawable pixelValue: aPixelValue [
	"Fill the rectangle of the given size with the provided colour."

	| localGC localGCValues height |
	localGCValues	:= CgGCValues new.
	localGC := aCgDrawable createGC: None values: localGCValues.
	height := aRectangle extent y.

	"Make sure we have the currect colour setting.  If not, change it."
	( localGCValues foreground = aPixelValue ) ifFalse: [
		localGCValues foreground: aPixelValue.
		localGC
			changeGC: GCForeground
			values: localGCValues
	].

	"Make sure we have the currect lineWidth setting (ie. the height of the rectangle).  If not, change it."
	( localGCValues lineWidth = height ) ifFalse:[
		localGCValues lineWidth: height.
		localGC
			changeGC: GCLineWidth
			values: localGCValues
	].

	"Fill the rectangle."
	^aCgDrawable
		fillRectangle: localGC
		x: aRectangle origin x
		y: aRectangle origin y
		width: aRectangle extent x
		height: aRectangle extent y
]

{ #category : 'Internal - Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> fillRectangle: aRectangle pixelValue: aPixelValue [
	"Fill the rectangle of the given size with the provided colour."

	| height |
	height := aRectangle extent y.

	"Make sure we have the currect colour setting.  If not, change it."
	( self gcValues foreground = aPixelValue ) ifFalse: [
		self gcValues foreground: aPixelValue.
		self gc
			changeGC: GCForeground
			values: self gcValues
	].

	"Make sure we have the currect lineWidth setting (ie. the height of the rectangle).  If not, change it."
	( self gcValues lineWidth = height ) ifFalse:[
		self gcValues lineWidth: height.
		self gc
			changeGC: GCLineWidth
			values: self gcValues
	].

	"Fill the rectangle."
	^self window
		fillRectangle: self gc
		x: aRectangle origin x
		y: aRectangle origin y
		width: aRectangle extent x
		height: aRectangle extent y
]

{ #category : 'Internal - Drawing',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> fillWithPixelValue: aPixelValue [
	"Fill the receiver with the provided colour."

	^self fillRectangle: ((0@0) extent: (self width @ self height)) pixelValue: aPixelValue
]

{ #category : 'Callbacks' }
TetrisDrawableAreaWidget >> focus: aCwDrawingArea clientData: clientData callData: aCwAnyCallbackData [

	"Process the focus callback."

	"Note:
		The callData type is CwAnyCallbackData. The reason is XmCRFOCUS
		or XmCRLOSINGFOCUS."

]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> fullRefreshRequired [
	"Return the value of fullRefreshRequired."

	^fullRefreshRequired
]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> fullRefreshRequired: aBoolean [
	"Save the value of fullRefreshRequired."

	fullRefreshRequired := aBoolean.

]

{ #category : 'Accessors',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> gc [
	"Answer the graphics resource.  Create it if it does not exist."

	( gc notNil ) ifFalse: [ self setupGC ].

	^gc
]

{ #category : 'Accessors',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> gc: aGC [
	"Set the current Graphics Context."

	^gc := aGC
]

{ #category : 'Accessors',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> gcValues [
	"Answer the current gc values."

	^gcValues
]

{ #category : 'Accessors',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> gcValues: aGCValues [
	"Set the current gc values."

	^gcValues := aGCValues
]

{ #category : 'Callbacks' }
TetrisDrawableAreaWidget >> input: aCwDrawingArea clientData: clientData event: aCwInputEvent [
	"An Input event has occured in the DrawingArea. Process the input callback."

]

{ #category : 'Callbacks' }
TetrisDrawableAreaWidget >> losingFocus: aCwDrawingArea clientData: clientData callData: aCwAnyCallbackData [

	"The widget has lost the input focus."


]

{ #category : 'API' }
TetrisDrawableAreaWidget >> osWidgetHandle [
	"Answer the Windows handle (HWND) of the receiver's osWidget."

	^self osWidget ifNotNil: [ :osw | osw handle ]
]

{ #category : 'Internal',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> pixelValueOfRgbColour: aColor [
	"Answer the pixel colour value for aCgRGBColor."

	aColor isColor ifFalse: [ ^0 ].
	^CgIndexedPalette default nearestPixelValue: aColor
]

{ #category : 'API' }
TetrisDrawableAreaWidget >> redraw [
	"Refresh the window."

	^self refresh
]

{ #category : 'API' }
TetrisDrawableAreaWidget >> refresh [
	"Refresh the window."

	"If we do not have a graphics context, do nothing."
	( gc notNil ) ifFalse: [ ^nil ].

	( self fullRefreshRequired = true ) ifTrue: [
		self clearRectangle: ((0 @ 0) extent: (self width @ self height)).
		self fullRefreshRequired: false.
	].

	self drawFallingBlock.
	self drawStationaryBlocks.

	( self shouldShowGrid = true )
		ifTrue: [ self drawGrid ].

	^self
]

{ #category : 'API' }
TetrisDrawableAreaWidget >> registerFallingBlock: aTetrisBlock [

	^self fallingBlock: aTetrisBlock
]

{ #category : 'Callbacks' }
TetrisDrawableAreaWidget >> resize: widget clientData: clientData callData: callData [
	"The drawing area has been resized."

	widget window clearArea: 0 y: 0 width: 0 height: 0 exposures: true

]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> rowCount [
	"Return the value of rowCount."

	^rowCount
]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> rowCount: anInteger [
	"Save the value of rowCount."

	rowCount := anInteger.

]

{ #category : 'API' }
TetrisDrawableAreaWidget >> setFallingBlockAsStationary [

	| stuckBlock |
	stuckBlock := self fallingBlock.

	self fallingBlock: nil.
	currentFallingBlock := nil.

	^stuckBlock
]

{ #category : 'Internal',
  #vaVisibility : 'private' }
TetrisDrawableAreaWidget >> setupGC [
	"Answer the graphics resource.  Create it if it does not exist."

	self gcValues: (CgGCValues new).

	self gc: (self screen rootWindow createGC: None values: self gcValues).

	^self
]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> shouldShowGrid [

	^shouldShowGrid
]

{ #category : 'Accessors' }
TetrisDrawableAreaWidget >> shouldShowGrid: aBoolean [

	shouldShowGrid := aBoolean.

]
